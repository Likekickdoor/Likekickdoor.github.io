<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="本页收集一些有趣的Java面试问题，其中可以深入的了解J一些ava这门语言的特性和其所结合的其他计算机知识。 synchronized和volatile的应用场景区别synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字">
<meta property="og:type" content="article">
<meta property="og:title" content="Java面试问题">
<meta property="og:url" content="http://yoursite.com/2019/06/10/Java面试问题/index.html">
<meta property="og:site_name" content="LikeKickDoorBlog">
<meta property="og:description" content="本页收集一些有趣的Java面试问题，其中可以深入的了解J一些ava这门语言的特性和其所结合的其他计算机知识。 synchronized和volatile的应用场景区别synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-07-25T09:08:26.474Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java面试问题">
<meta name="twitter:description" content="本页收集一些有趣的Java面试问题，其中可以深入的了解J一些ava这门语言的特性和其所结合的其他计算机知识。 synchronized和volatile的应用场景区别synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":true,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/06/10/Java面试问题/"/>





  <title>Java面试问题 | LikeKickDoorBlog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">LikeKickDoorBlog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/10/Java面试问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JeffLiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/daxiao.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LikeKickDoorBlog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Java面试问题</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-10T21:36:29+08:00">
                2019-06-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>本页收集一些有趣的Java面试问题，其中可以深入的了解J一些ava这门语言的特性和其所结合的其他计算机知识。</p>
<h3 id="synchronized和volatile的应用场景区别"><a href="#synchronized和volatile的应用场景区别" class="headerlink" title="synchronized和volatile的应用场景区别"></a>synchronized和volatile的应用场景区别</h3><p>synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为<strong>volatile关键字无法保证操作的原子性</strong>。<br>通常来说，使用volatile必须具备以下2个条件：  </p>
<ol>
<li>对变量的写操作不依赖于当前值</li>
<li>该变量没有包含在具有其他变量的不变式中  </li>
</ol>
<p><a href="https://www.cnblogs.com/dolphin0520/p/3920373.html" target="_blank" rel="external">参考volatile关键字解析，了解计算机系统并行概念三要点：原子性、可见性、有序性</a></p>
<h3 id="Java-类加载机制和反射"><a href="#Java-类加载机制和反射" class="headerlink" title="Java 类加载机制和反射"></a>Java 类加载机制和反射</h3><p><a href="http://www.importnew.com/30567.html" target="_blank" rel="external">参考传送门</a>  </p>
<h4 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h4><p>类加载器主要分为两类，一类是 JDK 默认提供的，一类是用户自定义的。 JDK 默认提供三种类加载器：  </p>
<ol>
<li>Bootstrap ClassLoader 启动类加载器：每次执行 java 命令时都会使用该加载器为虚拟机加载核心类。该加载器是由 native code 实现，而不是 Java 代码，加载类的路径为 <java_home>/jre/lib。特别的 <java_home>/jre/lib/rt.jar 中包含了 sun.misc.Launcher 类， 而 sun.misc.Launcher$ExtClassLoader 和 sun.misc.Launcher$AppClassLoader 都是 sun.misc.Launcher 的内部类，所以 <strong>拓展类加载器和系统类加载器都是由启动类加载器加载的</strong> 。</java_home></java_home></li>
<li>Extension ClassLoader, 拓展类加载器：用于加载拓展库中的类。拓展库路径为 <java_home>/jre/lib/ext/。实现类为 sun.misc.Launcher$ExtClassLoader</java_home></li>
<li>System ClassLoader 系统类加载器：用于加载 CLASSPATH 中的类。实现类为 sun.misc.Launcher$AppClassLoader</li>
</ol>
<p>用户自定义的加载器：<br>Custom ClassLoader, 一般都是 java.lang.ClassLoder 的子类  </p>
<p>正统的类加载机制是基于双亲委派的，也就是当调用类加载器加载类时，首先将加载任务委派给双亲，若双亲无法加载成功时，自己才进行类加载。  </p>
<p>在实例化一个新的类加载器时，我们可以为其指定一个 parent，即双亲，若未显式指定，则 System ClassLoader 就作为默认双亲。  </p>
<h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><p>Reflection（反射）是Java被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的內部信息，并能直接操作任意对象的内部属性及方法。<a href="https://www.cnblogs.com/tech-bird/p/3525336.html" target="_blank" rel="external">反射参考详细</a><br>Java反射机制主要提供了以下功能：</p>
<ul>
<li>在运行时构造任意一个类的对象</li>
<li>在运行时获取任意一个类所具有的成员变量和方法</li>
<li>在运行时调用任意一个对象的方法（属性）</li>
<li>生成动态代理  </li>
</ul>
<h3 id="ArrayList和LinkedList区别"><a href="#ArrayList和LinkedList区别" class="headerlink" title="ArrayList和LinkedList区别"></a>ArrayList和LinkedList区别</h3><p>通常情况下，ArrayList和LinkedList的区别有以下几点：</p>
<ol>
<li>ArrayList是实现了基于动态数组的数据结构，而LinkedList是基于链表的数据结构；</li>
<li>对于随机访问get和set，ArrayList要优于LinkedList，因为LinkedList要移动指针；</li>
<li>对于添加和删除操作add和remove，一般大家都会说LinkedList要比ArrayList快。</li>
</ol>
<h3 id="InputStream、OutputStream和Reader、Writer"><a href="#InputStream、OutputStream和Reader、Writer" class="headerlink" title="InputStream、OutputStream和Reader、Writer"></a>InputStream、OutputStream和Reader、Writer</h3><p>Java语言吧输入输出操作使用流来实现。按照数据的传输方向，流可以分为：  </p>
<ul>
<li>输入流</li>
<li>输出流</li>
</ul>
<p>按内容划分：</p>
<ul>
<li>字节流：处理字节数据（InputStream、OutputStream）</li>
<li>字符流：处理字符数据（Reader、Writer）</li>
</ul>
<p>数据流是Java程序发送和接受数据的一个通道，通常应用程序中使用输入流读出数据，输出流写入数据。  </p>
<p>InputStream、OutputStream和Reader、Writer都是<strong>抽象类</strong> ，一般都不会直接使用，通常根据这些类的派生子类对文件处理。  </p>
<p>标准输入输出流（静态流）（可以直接显示在显示台上）：  </p>
<ul>
<li>System.in是BufferedInputStream的对象</li>
<li>System.out是PrintSream的对象</li>
<li>System.err是PrintStream类派生的错误流</li>
</ul>
<h3 id="BIO和NIO、AIO的区别"><a href="#BIO和NIO、AIO的区别" class="headerlink" title="BIO和NIO、AIO的区别"></a>BIO和NIO、AIO的区别</h3><p>BIO：同步阻塞的BIO，面向流，是传统的IO模式，数据传输的过程是<strong>磁盘-&gt;内核空间缓冲区-&gt;用户空间缓冲区</strong><br>NIO：同步非阻塞的NIO，面向buffer，NIO本身是基于事件驱动思想来完成的，由一个线程监听事件，注册多个channel来处理线程发来的通知。<br><a href="https://blog.csdn.net/qq_28666081/article/details/82315086" target="_blank" rel="external">Java BIO与NIO的比较</a><br><a href="https://blog.csdn.net/ty497122758/article/details/78979302" target="_blank" rel="external">JAVA BIO与NIO、AIO的区别</a><br><a href="https://www.jianshu.com/p/8b3af5bf4ce1" target="_blank" rel="external">Java NIO与Java BIO的区别</a></p>
<h3 id="Java的跨平台原理"><a href="#Java的跨平台原理" class="headerlink" title="Java的跨平台原理"></a>Java的跨平台原理</h3><ol>
<li>Java通过不同的系统、不同版本、不同位数的Java虚拟机（Jvm），来屏蔽不同的系统指令集差异而对外提供统一的接口（Java API），对于我们普通的Java开发者而言，只需要按照接口开发即可。如果我们编写的程序需要部署到不同的环境时，只需要在系统上面按照对应版本的虚拟机即可。  </li>
<li>使用特定编译器编译的程序只能在对应的平台运行，这里也可以说编译器是与平台相关的，编译后的文件也是与平台相关的。<strong>我们说的语言跨平台是编译后的文件跨平台，而不是源程序跨平台</strong>，如果是源程序，任何一门语言都是跨平台的语言了。</li>
</ol>
<h3 id="面向对象的特征有哪些方面？（封装、抽象、继承、多态）"><a href="#面向对象的特征有哪些方面？（封装、抽象、继承、多态）" class="headerlink" title="面向对象的特征有哪些方面？（封装、抽象、继承、多态）"></a>面向对象的特征有哪些方面？（封装、抽象、继承、多态）</h3><ol>
<li>面向对象的封装性，即将对象封装成一个<strong>高度自治和相对封闭的个体</strong>，对象状态（属性）由这个对象自己的行为（方法）来读取和改变。如：<br>某个对象有自己的属性和自己提供的获取或改变的方法来操作。</li>
<li>抽象，就是找出一些对象的相似和共性之处，将这些对象归为一个类。这个过程就是抽象。</li>
<li>继承，在定义和实现一个类的时候，可以在已经存在的类的基础之上，把已经存在的内容作为自己的内容，并可以对此修改增减。如，遗产继承。</li>
<li>多态，一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪各类中实现的方法，必须在由程序运行期间才能决定。<br>靠的是父类或接口定义的引用变量可以指向子类或具体实现类的实例对象，而程序调用的方法在运行期才动态绑定，就是引用变量所指向的具体实例对象的方法，也就是内存里正在运行的那个对象的方法，而不是引用变量的类型中定义的方法。如：  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Object obj = <span class="keyword">new</span> xxx();</div><div class="line">UserDao userDao = <span class="keyword">new</span> UserDaoJdbcImp();</div><div class="line">UserDao userDao = <span class="keyword">new</span> UserDaoHibernateImp();</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="有了8中基本类型，为什么还需要包装类型"><a href="#有了8中基本类型，为什么还需要包装类型" class="headerlink" title="有了8中基本类型，为什么还需要包装类型"></a>有了8中基本类型，为什么还需要包装类型</h3><ul>
<li>装箱：把基本的数据类型转换成包装类型Integer.valueOf(1)</li>
<li>自动装箱：Integer=1；实际上在编译时会调用Integer.valueOf(1)方法来装箱。</li>
<li>拆箱：把包装类型转换成基本的数据类型，Integer i = 1;int j = i.intValue();//手动拆箱</li>
<li>自动拆箱：实际上会自动调用intValue()，Integer i = 1;int j = i;</li>
<li>回答：<br>Java是面向对象的语言，而基本数据类型不具备面向对象特性。<br>Integer具有MAX和MIN属性，和缓冲值：对象缓存。</li>
</ul>
<h3 id="“-”和equals-的区别？"><a href="#“-”和equals-的区别？" class="headerlink" title="“==”和equals()的区别？"></a>“==”和equals()的区别？</h3><ul>
<li>“==”用来判断两个变量之间的值是否相等。变量就可以分为基本数据类型变量，引用类型变量。如果是基本类型变量，直接比较变量值是否相同。而引用类型要比较对应的引用的内存首地址。</li>
<li>equals() 用来比较两个对象是否长得一样。判断两个对象的某些特征是否一样，实际上就是调用对象的equals()方法进行比较。</li>
</ul>
<h3 id="String、StringBuffer、StringBuilder"><a href="#String、StringBuffer、StringBuilder" class="headerlink" title="String、StringBuffer、StringBuilder"></a>String、StringBuffer、StringBuilder</h3><p>在Java中提供三个类String、StringBuffer、StringBuilder来表示和操作字符串。字符串就是多个字符的集合。  </p>
<ol>
<li>String 是内容不可变得字符串。String底层使用了不可变的字符数组（final char[]）。String str = new String(“bbb”)  </li>
<li>StringBuffer、StringBuilder是内容可以改变的字符串。StringBuilder、StringBuffer底层是使用可变的字符数组没使用final修饰  </li>
</ol>
<p>最经典的就是拼接字符串问题：  </p>
<ol>
<li>String c = “aa”+”bb”;这种效率最低，因为需要生成临时中间String对象，再合成最新String对象c</li>
<li>StringBuffer或StringBuilder举例使用append()方法，如：StringBuffer c = new  StringBuffer().append(“aa”).append(bb);</li>
</ol>
<p>StringBuffer和StringBuilder的区别是：StringBuilder是线程不安全的但速度最快，StringBuffer是线程安全的（加了同步锁synchronized）但速度较慢。</p>
<h3 id="讲一下Java中的集合"><a href="#讲一下Java中的集合" class="headerlink" title="讲一下Java中的集合"></a>讲一下Java中的集合</h3><p>Java中的集合分为value，key-value（分别归类：Collection、Map）两种。<br>存储值（value）有分为List和Set两种集合：</p>
<ol>
<li>List是有序的，可以重复。</li>
<li>Set是无序的，不可以重复。根据equals和hashcode判断，也就是如果一个对象要存储在Set中，必须重写equals和hashCode方法。<br>键值对（key-value）的为Map集合。</li>
</ol>
<h3 id="List常用的ArrayList和LinkedList的区别与应用场景"><a href="#List常用的ArrayList和LinkedList的区别与应用场景" class="headerlink" title="List常用的ArrayList和LinkedList的区别与应用场景"></a>List常用的ArrayList和LinkedList的区别与应用场景</h3><p>ArrayList，底层使用数组实现。LinkedList，底层使用链表实现<br>数组具有随机查询特定元素比较快，添加删除比较慢的特点。<br>链表不要求内存地址是连续的，当前元素存有下一个元素的地址。查询时需要从头一端开始一个个查询，速度慢，插入删除效率高。</p>
<h3 id="HashMap和HashTable及ConcurrentMap的区别"><a href="#HashMap和HashTable及ConcurrentMap的区别" class="headerlink" title="HashMap和HashTable及ConcurrentMap的区别"></a>HashMap和HashTable及ConcurrentMap的区别</h3><ol>
<li>相同点：HashMap和HashTable都可以使用来存储key-value的数据。</li>
<li>不同点：  </li>
</ol>
<ul>
<li>HashMap是可以吧null作为key或者value的，而HashTable是不可以的。  </li>
<li>HashMap是线程不安全的，效率较高。而HashTable是线程安全的，效率低。</li>
</ul>
<ol>
<li>HashMap和ConcurrentHashMap的区别：（既要安全又要效率高）<br>通过把整个Map分为N个Segment（类似HashTable）,每个可以提供相同的线程安全，但是效率提升N倍，默认提升16倍。</li>
</ol>
<h3 id="HashMap和HashSet的区别"><a href="#HashMap和HashSet的区别" class="headerlink" title="HashMap和HashSet的区别"></a>HashMap和HashSet的区别</h3><ul>
<li>HashMap：实现了Map接口、存储键值对、调用 put（）向map中添加元素、ashMap使用键（Key）计算Hashcode</li>
<li>HashSet：实现Set接口、仅存储对象、调用 add（）方法向Set中添加元素、HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，</li>
</ul>
<h3 id="线程有几种实现方式"><a href="#线程有几种实现方式" class="headerlink" title="线程有几种实现方式"></a>线程有几种实现方式</h3><ol>
<li><p>通过继承Tread类来实现一个线程。<br>①继承扩展性不高，java只支持单继承，如果一个类继承Thead类了，就无法再继承其他类<br>②启动：<br>Thread thread = new Thread(继承了Thread的对象/实现了Runnable的对象)<br>// thread.setName(“xxx”);<br>thread.start();<br>启动线程使用start方法，而启动执行的方法是run()方法中的内容<br>③如何区分线程？<br>thread.setName(“xxx”);这是一种规范，在创建线程完成后，都需要设置名称。</p>
</li>
<li><p>通过实现一个Runnable接口实现一个线程。  </p>
</li>
</ol>
<h3 id="线程并发库和线程池（连接池类似）的作用"><a href="#线程并发库和线程池（连接池类似）的作用" class="headerlink" title="线程并发库和线程池（连接池类似）的作用"></a>线程并发库和线程池（连接池类似）的作用</h3><p>JDK5.0 中增加了DougLea的并发库。Java通过Executors提供四个静态方法创建四种线性池，分别是：<br>newCachedThreadPool()，newWorkStealingPool()，newFixedThreadPool()，newSingleThreadExecutor()  </p>
<ul>
<li>线程池的作用<ol>
<li>限定线程的个数，不会导致由于线程过多导致系统运行缓慢或崩溃。  </li>
<li>线程池不需要每次都去创建或销毁，节约了资源。</li>
<li>线程池不需要每次都去创建，响应时间更快。</li>
</ol>
</li>
</ul>
<h3 id="常见的设计模式"><a href="#常见的设计模式" class="headerlink" title="常见的设计模式"></a>常见的设计模式</h3><p>设计模式就是经过前人无数次的实践总结出的。设计过程中可以反复使用的、可以解决特定问题的方法。如：<br>单例模式（饱汉模式、饥汉模式）：  </p>
<ol>
<li>构造方法私有化，只能够使自己类内部实例化自身。</li>
<li>在自己的类中实例化一个本身类的对象。（饱汉模式创建单实例是静态类属性，而饥汉模式本身为null后实例化返回该类对象）</li>
<li>提供一个方法获取实例对象（创建时需要进行方法同步）。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonFactory</span> </span>&#123; </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">PersonFactory</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">// 私有化构造方法</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="comment">// 饿汉模式，返回就有实例</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> PersonFactory instance = <span class="keyword">new</span> PersonFactory(); </div><div class="line"><span class="comment">// 提供方法获取instance</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PersonFactory <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> instance;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 懒汉模式，返回不一定已有实例</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> PersonFactory instance = <span class="keyword">null</span>; </div><div class="line"><span class="comment">// 提供方法获取instance，原本不加锁是不安全的可能被多次实例化，加锁synchronized后安全</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> PersonFactory <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</div><div class="line">        instance = <span class="keyword">new</span> PersonFactory();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> instance;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    PersonFactory.getInstance().toString();</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>工厂模式：分为简单工厂模式、工厂方法模式、抽象工厂模式。典型案例：SpringIOC<br>简单工厂：创建一个接口，再创建许多实现该接口的类，实现类的对象由一个工厂类来负责实例化。<a href="https://www.runoob.com/design-pattern/factory-pattern.html" target="_blank" rel="external">了解简单工厂模式</a><br>抽象工厂：在各个简单工厂继承于一个抽象工厂类AbstractFactory并覆盖自己那部分，再由一个工厂生成器类的静态方法：AbstractFactory getFactory(“xxxfactory”){…}负责生成各个简单工厂类的对象。<a href="https://www.runoob.com/design-pattern/abstract-factory-pattern.html" target="_blank" rel="external">了解抽象工厂模式</a><br>工厂方法：一个专门的抽象产品由各个具体产品继承，一个专门的抽象工厂由各个具体生产产品的工厂继承。客户端实例时使用具体的对象得到工厂，并使用工厂生产产品。调用产品方法。<a href="https://blog.csdn.net/qq_29676623/article/details/85795036" target="_blank" rel="external">了解工厂方法模式</a></p>
<p>代理模式：典型案例：SpringAOP就是使用动态代理<br>在代理模式中，一个类代表另一个类的功能。我们创建具有现有对象的对象，以便向外界提供功能接口。</p>
<h3 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a>GET和POST的区别</h3><p><strong>相同：</strong><br>GET和POST请求都是http的请求方式，用户通过不同http的请求方式完成对资源URL的不同操作。GET、POST、PUT、DELETE就对应着这个资源的增删改查4个操作。  </p>
<p><strong>差异：</strong><br>1、GET提交的数据会在地址栏显示出来，而POST请求不会在地址栏显示出来。<br>GET提交，请求数据会附在URL之后（就是把数据放置在HTTP协议头中），以？分割URL和传输数据，多个数据使用&amp;连接；POST提交，把提交的数据放置在HTTP数据报的报体中。<br>2、传输数据大小。GET因为地址长度的限制而导致传输的数据有限制，POST请求不会因为地址长度限制而导致传输数据限制。<br>3、安全性，GET因为数据在地址中出现，且可以在浏览器历史记录中找到。因此相对POST不安全。</p>
<h3 id="Servlet是什么，理解"><a href="#Servlet是什么，理解" class="headerlink" title="Servlet是什么，理解"></a>Servlet是什么，理解</h3><p>Servlet（Server Applet），全称Java Servlet，是用Java编写的服务器程序。Servlet是指任何实现了这个Servlet接口的类。其主要功能在于交互式地浏览和修改数据，生成动态Web内容。Servlet运行于支持Java的应用服务器。<br>HTTPServlet重写doGet和doPost方法或者你也可以重写serveice方法完成对GET或POST请求的响应。</p>
<h3 id="Servlet的生命周期"><a href="#Servlet的生命周期" class="headerlink" title="Servlet的生命周期"></a>Servlet的生命周期</h3><p>接口javax.servlet.Servlet接口包含有3个方法。init()、service()、destory()。三个方法与其生命周期有一定关联。<br>JVM加载Servlet的class—&gt;实例化Servlet—&gt;调用Servlet的init方法完成初始化（只被执行一次）—&gt;处理和响应请求调用service方法（可被执行多次）—&gt;Servlet容器被关闭是destory方法被执行（只被执行一次）</p>
<h3 id="JSP和Servlet有哪些相同点和不同点"><a href="#JSP和Servlet有哪些相同点和不同点" class="headerlink" title="JSP和Servlet有哪些相同点和不同点"></a>JSP和Servlet有哪些相同点和不同点</h3><p>JSP是Servlet技术的扩展，所有的JSP文件都会被编译成一个继承HTTPServlet的类，JSP最终也会是一个Servlet对外提供服务。<br>Servlet和Jsp主要不同点是，Servlet的应用逻辑在Java文件，完全从表示层中的HTML分离出来。而JSP的情况是Java代码和HTML可以组成一个扩展名为.jsp的文件。JSP侧重视图，而Servlet侧重控制逻辑。</p>
<h3 id="说一下session和cookie的区别，项目中的使用。"><a href="#说一下session和cookie的区别，项目中的使用。" class="headerlink" title="说一下session和cookie的区别，项目中的使用。"></a>说一下session和cookie的区别，项目中的使用。</h3><p><strong>相同点：</strong> session和cookie都是会话跟踪技术。Cookie通过客户端记录信息确定用户身份，session通过在服务器端跟踪记录信息确定用户身份。但是session的实现依赖于cookie，sessionId(session的唯一标示需要存放在客户端)。<br><strong>不同点：</strong><br>1、cookie数据存放在客户的浏览器上，session数据放在服务器上。<br>2、cookie不是很安全，可以通过存放在本地的cookie进行cookie欺骗，考虑安全时应当使用session<br>3、session在一定时间里存放服务器上，当访问增多，会较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用cookie。<br>4、 单个cookie保存的数据不能超过4k，很多浏览器都限定一个站点最多保存20个cookie。  </p>
<h3 id="数据库的分类和常用的数据库"><a href="#数据库的分类和常用的数据库" class="headerlink" title="数据库的分类和常用的数据库"></a>数据库的分类和常用的数据库</h3><p>数据库分类为：<br>关系型数据库（MySQL、Orcale、SQLservice）<br>非关系型数据库（redis、memCache、MongoDB、Hadoop）</p>
<h3 id="MVC模式和各个部分都有那些技术实现"><a href="#MVC模式和各个部分都有那些技术实现" class="headerlink" title="MVC模式和各个部分都有那些技术实现"></a>MVC模式和各个部分都有那些技术实现</h3><p>M(Model) 模型 Javabean<br>V(View) 视图 html、jsp、volicity、freemaker<br>C(Control) 控制器 Servlet、Action  </p>
<p>Jsp+Servlet+JavaBean 是经典的MVC模式，实现上就是Model2的实现方式，就是把视图和逻辑隔离开。<br>Model1的方式：jsp+service+dao<br>Model2的方式：jsp+servlet+service+dao  </p>
<p>使用struct2和SpringMVC这样的MVC框架后，Jsp+核心控制器+Action+JavaBean</p>
<h3 id="简单介绍一下关系数据库三范式"><a href="#简单介绍一下关系数据库三范式" class="headerlink" title="简单介绍一下关系数据库三范式"></a>简单介绍一下关系数据库三范式</h3><p>范式就是规范，想满足第二范式必须先满足第二范式，想满足第第三范式必须先满足第三范式。<br>1、 第一范式（1NF）是指数据库中的每一个列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。列数据的不可分割。<br>2、 第二范式（2NF）要求在满足第一范式的基础上，要求数据库表中的每一行必须可以被唯一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的唯一标示。（属性完全依赖于主键）<br>3、 第三范式（3NF）要求一个数据库的每个表中不包含其他表中已经包含的非主键关键字信息。（非主属性不传递函数依赖于键码。）</p>
<h3 id="事务四个基本特征ACID特征"><a href="#事务四个基本特征ACID特征" class="headerlink" title="事务四个基本特征ACID特征"></a>事务四个基本特征ACID特征</h3><p>事务是并发控制的基本单位，是用户定义的一个操作序列。这些操作要么都做，要么都不做，是一个不可分割的工作单位。<br>原子性（Atomicity）：表示事务内操作不可分割。要么都成功提交、要么都失败回滚。<br>一致性（Consistency）：数据库在事务执行前后都保持一致性状态，从一种正确状态转换到另一种正确状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。<br>隔离性（lsolation）：一个事务所做的修改在最终提交以前，对其他事务是不可见的。不能受其他事务影响。<br>持久性（Durability）：一旦事务提交，则其所做的修改将永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。</p>
<h3 id="MySQL数据库的默认最大连接数"><a href="#MySQL数据库的默认最大连接数" class="headerlink" title="MySQL数据库的默认最大连接数"></a>MySQL数据库的默认最大连接数</h3><p>MySQL数据库的my.ini文件中可以看见其默认最大连接数：max_connection=100；<br>为什么需要最大连接数？一般特定服务器上的数据库只支持一定数目同时连接，这时候都会设置最大连接数。</p>
<h3 id="★触发器的作用"><a href="#★触发器的作用" class="headerlink" title="★触发器的作用"></a>★触发器的作用</h3><p>触发器，需要有出发条件，当条件满足后做相应的操作。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">create</span> <span class="keyword">table</span> board1(<span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">11</span>) primary <span class="keyword">key</span> auto_increment,<span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">50</span>),articleCount <span class="built_in">int</span>(<span class="number">11</span>));</div><div class="line"><span class="keyword">create</span> <span class="keyword">table</span> article1(<span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">11</span>) primary <span class="keyword">key</span> auto_increment,title <span class="built_in">varchar</span>(<span class="number">50</span>) ,bid <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">references</span> board1(<span class="keyword">id</span>));</div><div class="line"></div><div class="line">delimiter |    <span class="comment">-- 将分隔符;改为|</span></div><div class="line"></div><div class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> interArticle_Trigger </div><div class="line"><span class="keyword">after</span> <span class="keyword">insert</span> <span class="keyword">on</span> article1 </div><div class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span> <span class="keyword">begin</span></div><div class="line">    <span class="keyword">update</span> boardi <span class="keyword">set</span> articleCount=articleCount+<span class="number">1</span> <span class="keyword">where</span> <span class="keyword">id</span>= NEW.bid;</div><div class="line"><span class="keyword">end</span>;|    <span class="comment">--结束符</span></div><div class="line"></div><div class="line">delimiter ;    <span class="comment">-- 将分隔符改为|</span></div><div class="line"></div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> board1 <span class="keyword">value</span> (<span class="literal">null</span>,<span class="string">'test'</span>,<span class="number">0</span>);</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> article1 <span class="keyword">value</span> (<span class="literal">null</span>,<span class="string">'test'</span>,<span class="number">1</span>); <span class="comment">-- 插入该该句后会更新上局中的articleCount</span></div></pre></td></tr></table></figure></p>
<h3 id="★数据库的存储过程"><a href="#★数据库的存储过程" class="headerlink" title="★数据库的存储过程"></a>★数据库的存储过程</h3><p>数据库<strong>存储过程</strong>具有如下优点：<br>存储过程 只在创建时进行编译，以后每次执行存储过程都不需要再重新编译，而一般SQL句每执行一次就编译一次，因此使用存储过程可以大大提高数据库执行速度。<br>通常，复杂的业务逻辑需要多条SQL语句，这些语句需要分别地从客户机发送到服务器，当客户机和服务器之间的操作很多时，将产生大量的网络传输。如果将这些操作放到一个存储过程中，客户机和服务器之间的网络传输就大大减少，降低了网络负载。<br>安全性高，存储过程可以屏蔽对底层数据库对象的直接访问，使用EXECUTE权限调用存储过程，无需访问底层数据库对象的显示权限。  </p>
<p>定义存储过程：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">delimiter // <span class="comment">--自定义分隔符</span></div><div class="line"></div><div class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> myprocedure( <span class="keyword">out</span> ret <span class="built_in">int</span> ) <span class="comment">--输出参数ret、当然还有out、in、inout三种参数</span></div><div class="line">    <span class="keyword">begin</span></div><div class="line">        <span class="keyword">declare</span> y <span class="built_in">int</span>; <span class="comment">-- 定义一个变量y</span></div><div class="line">        <span class="keyword">select</span> <span class="keyword">sum</span>(col1)</div><div class="line">        <span class="keyword">from</span> mytable</div><div class="line">        <span class="keyword">into</span> y; <span class="comment">-- 使用select ... into ... 将值付给y</span></div><div class="line">        <span class="keyword">select</span> y*y <span class="keyword">into</span> ret; <span class="comment">-- 将y*y的值计算出赋予ret</span></div><div class="line">    <span class="keyword">end</span> //</div><div class="line"></div><div class="line">delimiter ; <span class="comment">--自定义分隔符</span></div><div class="line"></div><div class="line"><span class="keyword">call</span> myprocedure(@ret); <span class="comment">-- 调用存储过程myprocedure，结果给参数ret</span></div><div class="line"><span class="keyword">select</span> @ret; <span class="comment">-- 得出参数结果</span></div><div class="line"></div><div class="line"><span class="comment">-- 例子二</span></div><div class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> insert_Student (_name <span class="built_in">varchar</span>(<span class="number">50</span>), _age <span class="built_in">int</span> ,<span class="keyword">out</span> _id <span class="built_in">int</span>)</div><div class="line"></div><div class="line"><span class="keyword">begin</span></div><div class="line"></div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">value</span>(<span class="literal">null</span>,_name,_age);</div><div class="line"><span class="keyword">select</span> <span class="keyword">max</span>(stuid) <span class="keyword">into</span> _id <span class="keyword">from</span> student;</div><div class="line"></div><div class="line"><span class="keyword">end</span>;</div><div class="line"></div><div class="line"><span class="keyword">call</span> insert_Student(<span class="string">'Jeff'</span>,<span class="number">23</span>,@<span class="keyword">id</span>);</div><div class="line"><span class="keyword">select</span> @<span class="keyword">id</span>;</div></pre></td></tr></table></figure></p>
<h3 id="Java调用存储过程"><a href="#Java调用存储过程" class="headerlink" title="Java调用存储过程"></a>Java调用存储过程</h3><p>JDBC中使用准备工作代码写完后，得到连接句柄conn，调用：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">cstmt = conn.prepareCall("&#123;call insert_Student(?,?,?)&#125;");</div><div class="line">cstmt.registerOutParameter(3,Types.INTEGER); <span class="comment">-- 第三个参数是Out输出结果</span></div><div class="line">cstmt.setString(1,"wangwu");</div><div class="line">cstmt.setInt(2,25);</div><div class="line">cstmt.execute();</div></pre></td></tr></table></figure></p>
<h3 id="JDBC访问MySQL过程"><a href="#JDBC访问MySQL过程" class="headerlink" title="JDBC访问MySQL过程"></a>JDBC访问MySQL过程</h3><p><strong>贾琏欲执事</strong>：  </p>
<ul>
<li>加载驱动(com.mysql.jdbc.Driver;oracle.jdbc.driver.OracleDriver)</li>
<li>获取连接(DriverManager.getConnection(URL,USERNAEM,PASSWORD))</li>
<li>预先设置参数(Statement stmt、PreparedStatement pstmt)–&gt;stmt.setVaribleType(index,value);</li>
<li>执行 (executeQuery、executeUpdate)</li>
<li>释放连接(是否连接从小到大，必须放到finally)</li>
</ul>
<h3 id="JDBC中PreparedStatement较Statement的优势"><a href="#JDBC中PreparedStatement较Statement的优势" class="headerlink" title="JDBC中PreparedStatement较Statement的优势"></a>JDBC中PreparedStatement较Statement的优势</h3><ol>
<li>PreparedStatement是预编译的，速度较快。</li>
<li>代码可读性更高些。</li>
<li>安全性高些，PreparedStatement可以防止SQL注入，而Statement却不能。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 举个栗子</span></div><div class="line">String sql = <span class="string">"SELECT *FROM `user` WHERE `username`='"</span>+username+<span class="string">"' AND `passwd`='"</span>+passwd+<span class="string">"'"</span>;</div><div class="line"><span class="comment">// 将参数【' OR '1'='1】作为passwd传入，实际上最后执行语句是：</span></div><div class="line">sql = <span class="string">" SELECT *FROM `user` WHERE `username`='xxx' AND `passwd`='' OR '1'='1' "</span>;</div><div class="line"><span class="comment">// 甚至如果passwd的参数值为【';DROP TABLE user;】将会删除一个表</span></div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="数据库连接池的作用"><a href="#数据库连接池的作用" class="headerlink" title="数据库连接池的作用"></a>数据库连接池的作用</h3><ol>
<li>限定数据库的个数，不会导致系统因内存资源不足崩溃。</li>
<li>数据库不用每次都创建或销毁连接，节约了资源。</li>
<li>数据库不用每次都创建连接，提高了速度。</li>
</ol>
<h3 id="什么是Java事务"><a href="#什么是Java事务" class="headerlink" title="什么是Java事务"></a>什么是Java事务</h3><ol>
<li>Java事务的产生：<br>程序操作数据库的需要。在Java编写的程序或系统中，实现ACID的操作。</li>
<li>Java事务实现的范围：<br>通过JDBC相应方法间接实现对对数据库的增、删、改、查，把事务转移到Java程序中进行控制。<br>确保程序要么成功，要么撤销不执行。</li>
<li>总结：<br>Java事务机制和原理就是确保数据库操作的ACID特性。</li>
</ol>
<h3 id="Java中类的修饰符"><a href="#Java中类的修饰符" class="headerlink" title="Java中类的修饰符"></a>Java中类的修饰符</h3><ol>
<li>外部类的修饰符含义：  </li>
</ol>
<ul>
<li>public : 将一个类声明为公共类，它可以被任何对象访问。</li>
<li>abstract : 将一个类声明为抽象类，没有实现方法（但是可以实现），需要子类提供方法的实现，所以不能创建该类的实例。</li>
<li>final : 将一个类声明为最终类即非继承类，表示他不能被其他类所继承。</li>
<li>缺省 ： 缺省修饰符则表示只有在相同包中的对象才能使用这样的类。</li>
<li>注意 : 定义类可以有多个修饰符，但是abstract和final不能同时出现</li>
</ul>
<ol>
<li>内部类的修饰符含义</li>
</ol>
<ul>
<li>public：内部类中可以直接通过创建对象，从外部类之外被调用，必须将内部声明为public</li>
<li>private：当一个内部类使用了private修饰后，只能在该类的外部类内部使用。</li>
<li>protected：可以被子类和自己使用</li>
<li>final：不可以被继承</li>
<li>abstractt：但必须被外部类中其他内部类继承或实现</li>
</ul>
<ol>
<li>总结：<br>final修饰变量表示不可更改，修饰类不可继承、修饰方法不可重载。<br>缺省只能在同一个包中被使用<br><a href="https://www.cnblogs.com/jianhck/p/4288874.html" target="_blank" rel="external">了解更多</a></li>
</ol>
<h3 id="Java中静态初始化器、实例变量初始化器、构造器的执行顺序"><a href="#Java中静态初始化器、实例变量初始化器、构造器的执行顺序" class="headerlink" title="Java中静态初始化器、实例变量初始化器、构造器的执行顺序"></a>Java中静态初始化器、实例变量初始化器、构造器的执行顺序</h3><p>1、可以通过实例变量初始化器来初始化较复杂的实例变量，实例变量初始化器是一个用{}包含的语句块，在类的构造器被调用时运行，运行于父类构造器之后，构造器之前。<br>2、类变量(静态变量)也可以通过类变量初始化器来进行初始化，类变量初始化器是一个用static{}包含的语句块，只可能被初始化一次</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> test.ctrltab.xyz;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">Test</span></span>&#123;	</div><div class="line">	StringBuffer s ;</div><div class="line">	<span class="keyword">static</span> &#123;</div><div class="line">		System.out.println(<span class="string">"我是类变量初始化器"</span>);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	&#123;</div><div class="line">		s = <span class="keyword">new</span> StringBuffer(<span class="string">"我是实例变量初始化器"</span>);</div><div class="line">		System.out.println(s);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">()</span></span>&#123;</div><div class="line">		System.out.println(<span class="string">"我是构造函数"</span>);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</div><div class="line">		System.out.println(<span class="string">"hello,world,Solution..."</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		Solution a = <span class="keyword">new</span> Solution();</div><div class="line">		a.say();</div><div class="line">	&#125;	</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">	<span class="keyword">static</span> &#123;</div><div class="line">		System.out.println(<span class="string">"我是Test类变量初始化器"</span>);</div><div class="line">	&#125;</div><div class="line">    StringBuffer s ;</div><div class="line">	&#123;</div><div class="line">        s = <span class="keyword">new</span> StringBuffer(<span class="string">"我是Test实例变量初始化器"</span>);</div><div class="line">		System.out.println(s);</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span></span>&#123;</div><div class="line">		System.out.println(<span class="string">"我是Test构造函数"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</div><div class="line">		System.out.println(<span class="string">"hello,world,Test..."</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">执行结果：</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">我是Test类变量初始化器</span></div><div class="line"><span class="comment">我是类变量初始化器</span></div><div class="line"><span class="comment">我是Test实例变量初始化器</span></div><div class="line"><span class="comment">我是Test构造函数</span></div><div class="line"><span class="comment">我是实例变量初始化器</span></div><div class="line"><span class="comment">我是构造函数</span></div><div class="line"><span class="comment">hello,world,Solution...</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">//总体顺序是：</span></div><div class="line"><span class="comment">1、 先执行静态初始化器中的代码，由父类到子类。</span></div><div class="line"><span class="comment">2、 再到父类实例初始化器和构造器</span></div><div class="line"><span class="comment">3、 再到子类的初始化器和构造器</span></div><div class="line"><span class="comment">4、 再到子类的main方法</span></div><div class="line"><span class="comment">*/</span></div></pre></td></tr></table></figure>
<h3 id="Java对象的深度克隆和浅克隆"><a href="#Java对象的深度克隆和浅克隆" class="headerlink" title="Java对象的深度克隆和浅克隆"></a>Java对象的深度克隆和浅克隆</h3><p><a href="https://www.cnblogs.com/gollong/p/9668699.html" target="_blank" rel="external">详情</a></p>
<h3 id="JVM-及-垃圾回收机制原理"><a href="#JVM-及-垃圾回收机制原理" class="headerlink" title="JVM 及 垃圾回收机制原理"></a>JVM 及 垃圾回收机制原理</h3><p><a href="https://www.cnblogs.com/zjdxr-up/p/8995275.html" target="_blank" rel="external">详情</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/05/27/知识普及/" rel="next" title="科普知识集">
                <i class="fa fa-chevron-left"></i> 科普知识集
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/06/24/Java-Spring学习总结01/" rel="prev" title="Spring学习总结01">
                Spring学习总结01 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/uploads/daxiao.jpg"
                alt="JeffLiu" />
            
              <p class="site-author-name" itemprop="name">JeffLiu</p>
              <p class="site-description motion-element" itemprop="description">To be good at everything</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            

          </nav>

          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/likekickdoor" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i></a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:yourname@gmail.com" target="_blank" title="E-Mail">
                    
                      <i class="fa fa-fw fa-envelope"></i></a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://plus.google.com/yourname" target="_blank" title="Google">
                    
                      <i class="fa fa-fw fa-google"></i></a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://twitter.com/yourname" target="_blank" title="Twitter">
                    
                      <i class="fa fa-fw fa-twitter"></i></a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized和volatile的应用场景区别"><span class="nav-number">1.</span> <span class="nav-text">synchronized和volatile的应用场景区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-类加载机制和反射"><span class="nav-number">2.</span> <span class="nav-text">Java 类加载机制和反射</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#类加载机制"><span class="nav-number">2.1.</span> <span class="nav-text">类加载机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#反射"><span class="nav-number">2.2.</span> <span class="nav-text">反射</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ArrayList和LinkedList区别"><span class="nav-number">3.</span> <span class="nav-text">ArrayList和LinkedList区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#InputStream、OutputStream和Reader、Writer"><span class="nav-number">4.</span> <span class="nav-text">InputStream、OutputStream和Reader、Writer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BIO和NIO、AIO的区别"><span class="nav-number">5.</span> <span class="nav-text">BIO和NIO、AIO的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java的跨平台原理"><span class="nav-number">6.</span> <span class="nav-text">Java的跨平台原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#面向对象的特征有哪些方面？（封装、抽象、继承、多态）"><span class="nav-number">7.</span> <span class="nav-text">面向对象的特征有哪些方面？（封装、抽象、继承、多态）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#有了8中基本类型，为什么还需要包装类型"><span class="nav-number">8.</span> <span class="nav-text">有了8中基本类型，为什么还需要包装类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#“-”和equals-的区别？"><span class="nav-number">9.</span> <span class="nav-text">“==”和equals()的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String、StringBuffer、StringBuilder"><span class="nav-number">10.</span> <span class="nav-text">String、StringBuffer、StringBuilder</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#讲一下Java中的集合"><span class="nav-number">11.</span> <span class="nav-text">讲一下Java中的集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#List常用的ArrayList和LinkedList的区别与应用场景"><span class="nav-number">12.</span> <span class="nav-text">List常用的ArrayList和LinkedList的区别与应用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap和HashTable及ConcurrentMap的区别"><span class="nav-number">13.</span> <span class="nav-text">HashMap和HashTable及ConcurrentMap的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap和HashSet的区别"><span class="nav-number">14.</span> <span class="nav-text">HashMap和HashSet的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程有几种实现方式"><span class="nav-number">15.</span> <span class="nav-text">线程有几种实现方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程并发库和线程池（连接池类似）的作用"><span class="nav-number">16.</span> <span class="nav-text">线程并发库和线程池（连接池类似）的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常见的设计模式"><span class="nav-number">17.</span> <span class="nav-text">常见的设计模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GET和POST的区别"><span class="nav-number">18.</span> <span class="nav-text">GET和POST的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Servlet是什么，理解"><span class="nav-number">19.</span> <span class="nav-text">Servlet是什么，理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Servlet的生命周期"><span class="nav-number">20.</span> <span class="nav-text">Servlet的生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JSP和Servlet有哪些相同点和不同点"><span class="nav-number">21.</span> <span class="nav-text">JSP和Servlet有哪些相同点和不同点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#说一下session和cookie的区别，项目中的使用。"><span class="nav-number">22.</span> <span class="nav-text">说一下session和cookie的区别，项目中的使用。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据库的分类和常用的数据库"><span class="nav-number">23.</span> <span class="nav-text">数据库的分类和常用的数据库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MVC模式和各个部分都有那些技术实现"><span class="nav-number">24.</span> <span class="nav-text">MVC模式和各个部分都有那些技术实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#简单介绍一下关系数据库三范式"><span class="nav-number">25.</span> <span class="nav-text">简单介绍一下关系数据库三范式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#事务四个基本特征ACID特征"><span class="nav-number">26.</span> <span class="nav-text">事务四个基本特征ACID特征</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL数据库的默认最大连接数"><span class="nav-number">27.</span> <span class="nav-text">MySQL数据库的默认最大连接数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#★触发器的作用"><span class="nav-number">28.</span> <span class="nav-text">★触发器的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#★数据库的存储过程"><span class="nav-number">29.</span> <span class="nav-text">★数据库的存储过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java调用存储过程"><span class="nav-number">30.</span> <span class="nav-text">Java调用存储过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JDBC访问MySQL过程"><span class="nav-number">31.</span> <span class="nav-text">JDBC访问MySQL过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JDBC中PreparedStatement较Statement的优势"><span class="nav-number">32.</span> <span class="nav-text">JDBC中PreparedStatement较Statement的优势</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据库连接池的作用"><span class="nav-number">33.</span> <span class="nav-text">数据库连接池的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是Java事务"><span class="nav-number">34.</span> <span class="nav-text">什么是Java事务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java中类的修饰符"><span class="nav-number">35.</span> <span class="nav-text">Java中类的修饰符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java中静态初始化器、实例变量初始化器、构造器的执行顺序"><span class="nav-number">36.</span> <span class="nav-text">Java中静态初始化器、实例变量初始化器、构造器的执行顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java对象的深度克隆和浅克隆"><span class="nav-number">37.</span> <span class="nav-text">Java对象的深度克隆和浅克隆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM-及-垃圾回收机制原理"><span class="nav-number">38.</span> <span class="nav-text">JVM 及 垃圾回收机制原理</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">JeffLiu</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.3</div>




        







        
      </div>
    </footer>

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  








  





  

  

  

  

  

  

</body>
</html>
